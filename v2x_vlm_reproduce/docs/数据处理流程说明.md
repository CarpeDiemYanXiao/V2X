# V2X-VLM 数据处理完整文档

## 1. 核心问题解答

### Q1: 车端和路端图片是按照一样的文件名读取吗？

**不是！** 车端和路端图片的文件名是**不同的**，需要通过 `cooperative/data_info.json` 配对。

```
cooperative/data_info.json 中一条记录:
{
  "vehicle_image_path": "vehicle-side/image/015438.jpg",        # 车端: 015438
  "infrastructure_image_path": "infrastructure-side/image/000084.jpg"  # 路端: 000084
}
```

**配对关系**: 通过时间戳对齐，同一时刻的车端和路端图像 frame_id 不同。

### Q2: frame_id 的定义

- **vehicle_frame_id**: 车端图像文件名 (不含扩展名)，如 `015438`
- **infra_frame_id**: 路端图像文件名 (不含扩展名)，如 `000084`
- 这两个 ID 是**独立编号系统**，不相等

### Q3: batch_frames 如何组织

`batch_frames` 来自 `vehicle-side/data_info.json` 中的 `batch_id` 字段：

```python
# vehicle-side/data_info.json 中每个帧包含:
{
  "image_path": "image/020502.jpg",
  "batch_id": "34",           # ⭐ 序列ID (同一连续驾驶场景)
  "batch_start_id": "004015", # 序列起始帧
  "batch_end_id": "004226",   # 序列结束帧
  "image_timestamp": "1626247179676000"  # 时间戳 (微秒)
}
```

**组织方式**:
1. 按 `batch_id` 分组
2. 每组内按 `image_timestamp` 时间戳排序
3. 同一 batch 内的帧是**时间连续**的，可以构建轨迹

---

## 2. 数据处理流程图

```
                    ┌─────────────────────────────────────────────────────────┐
                    │              cooperative/data_info.json                  │
                    │   (车路配对关系: vehicle_frame ↔ infra_frame)            │
                    └─────────────────────────┬───────────────────────────────┘
                                              │
                    ┌─────────────────────────┴───────────────────────────────┐
                    │                                                         │
                    ▼                                                         ▼
    ┌───────────────────────────────┐               ┌───────────────────────────────┐
    │   vehicle_frame_id: 015438    │               │   infra_frame_id: 000084      │
    └───────────────┬───────────────┘               └───────────────┬───────────────┘
                    │                                               │
                    ▼                                               ▼
    ┌───────────────────────────────┐               ┌───────────────────────────────┐
    │ vehicle-side-image/015438.jpg │               │ infra-side-image/000084.jpg   │
    └───────────────┬───────────────┘               └───────────────┬───────────────┘
                    │                                               │
                    └─────────────────────┬─────────────────────────┘
                                          │
                                          ▼
                    ┌─────────────────────────────────────────────────────────┐
                    │           图像拼接 [I_v, I_i]                            │
                    │     (768×768) + (768×768) = (768×1536)                   │
                    └─────────────────────────────────────────────────────────┘
```

---

## 3. 数据文件关系详解

### 3.1 三个核心 data_info.json

| 文件 | 作用 | 关键字段 |
|------|------|---------|
| `vehicle-side/data_info.json` | 车端帧元数据 | `batch_id`, `image_timestamp`, `calib_novatel_to_world_path` |
| `infrastructure-side/data_info.json` | 路端帧元数据 | `batch_id`, `image_timestamp` |
| `cooperative/data_info.json` | **车路配对** | `vehicle_image_path`, `infrastructure_image_path` |

### 3.2 cooperative/data_info.json 详细格式

```json
[
  {
    "infrastructure_image_path": "infrastructure-side/image/000084.jpg",
    "infrastructure_pointcloud_path": "infrastructure-side/velodyne/000084.pcd",
    "vehicle_image_path": "vehicle-side/image/015438.jpg",
    "vehicle_pointcloud_path": "vehicle-side/velodyne/015438.pcd",
    "cooperative_label_path": "cooperative/label_world/015438.json",
    "system_error_offset": {
      "delta_x": 0,
      "delta_y": 0
    }
  },
  // ... 共 6617 条配对记录
]
```

### 3.3 vehicle-side/data_info.json 详细格式

```json
[
  {
    "image_path": "image/020502.jpg",
    "image_timestamp": "1626247179676000",
    "pointcloud_path": "velodyne/020502.pcd",
    "pointcloud_timestamp": "1626247179628753",
    "calib_novatel_to_world_path": "calib/novatel_to_world/020502.json",
    "calib_lidar_to_novatel_path": "calib/lidar_to_novatel/020502.json",
    "calib_lidar_to_camera_path": "calib/lidar_to_camera/020502.json",
    "calib_camera_intrinsic_path": "calib/camera_intrinsic/020502.json",
    "label_camera_std_path": "label/camera/020502.json",
    "label_lidar_std_path": "label/lidar/020502.json",
    "batch_id": "34",
    "batch_start_id": "004015",
    "batch_end_id": "004226",
    "intersection_loc": ""
  },
  // ... 共 15285 条记录
]
```

---

## 4. batch_frames 组织详解

### 4.1 什么是 batch_id

`batch_id` 表示一段**连续的驾驶场景**，同一 batch 内的帧：
- 时间连续（相邻帧间隔约 100ms，10Hz）
- 空间连续（车辆在同一条道路上行驶）
- 可以用来构建轨迹序列

### 4.2 如何组织 batch_frames

```python
from collections import defaultdict

def group_frames_by_batch(data_info):
    """
    按 batch_id 分组，并按时间戳排序
    """
    batches = defaultdict(list)
    
    for item in data_info:
        batch_id = item['batch_id']
        batches[batch_id].append(item)
    
    # 每组内按时间戳排序 (保证时间连续性)
    for batch_id in batches:
        batches[batch_id].sort(key=lambda x: int(x['image_timestamp']))
    
    return batches
```

### 4.3 示例：batch_id = "34" 的帧序列

```
batch_34:
├── frame 0: 004015.jpg, timestamp: 1626247100000000
├── frame 1: 004016.jpg, timestamp: 1626247100100000  (+100ms)
├── frame 2: 004017.jpg, timestamp: 1626247100200000  (+100ms)
├── ...
└── frame 211: 004226.jpg, timestamp: 1626247121100000
```

---

## 5. GT轨迹生成流程

### 5.1 为什么只用 vehicle-side/data_info.json 组织轨迹

**因为GT轨迹是自车的未来位置**，只需要车端数据：

1. **位姿来源**: `calib/novatel_to_world/*.json` 提供自车世界坐标
2. **时间连续性**: 通过 `batch_id` 和 `timestamp` 确保帧顺序正确
3. **轨迹构建**: 在同一 batch 内，取当前帧后 45 帧的位置作为 GT

### 5.2 GT轨迹生成伪代码

```python
# 1. 加载车端元数据
vehicle_data_info = load_json("vehicle-side/data_info.json")

# 2. 按 batch_id 分组并排序
batches = group_frames_by_batch(vehicle_data_info)

# 3. 对每个 batch 中的每一帧生成轨迹
for batch_id, frames in batches.items():
    for i, current_frame in enumerate(frames):
        # 检查是否有足够的未来帧 (需要45帧)
        if i + 45 >= len(frames):
            continue  # 跳过末尾帧
        
        # 获取当前帧位姿
        current_frame_id = current_frame['image_path'].split('/')[-1].replace('.jpg', '')
        current_pose = load_pose(f"novatel_to_world/{current_frame_id}.json")
        
        # 收集未来45帧的位置
        future_trajectory = []
        for j in range(1, 46):  # 1到45
            future_frame = frames[i + j]
            future_frame_id = future_frame['image_path'].split('/')[-1].replace('.jpg', '')
            future_pose = load_pose(f"novatel_to_world/{future_frame_id}.json")
            future_trajectory.append([future_pose.x, future_pose.y])
        
        # 转换到自车中心坐标系
        ego_trajectory = world_to_ego_centric(future_trajectory, current_pose)
        
        # 保存
        np.save(f"ground_truth_trajectories/{current_frame_id}.npy", ego_trajectory)
```

### 5.3 坐标转换说明

```
世界坐标系 (World)          自车中心坐标系 (Ego-centric)
        N                           ↑ Y (左)
        ↑                           │
        │                    ←──────┼──────→ X (前)
   W ←──┼──→ E                      │
        │                           ↓
        ↓
        S

转换步骤:
1. 平移: 将原点移到当前帧自车位置
2. 旋转: 将自车朝向对齐到X轴正方向
```

---

## 6. 数据加载完整流程

```python
class V2XVLMDataset:
    def __init__(self):
        # 1. 加载 cooperative/data_info.json 获取车路配对
        self.coop_data = load_json("cooperative/data_info.json")
        
        # 2. 加载 vehicle-side/data_info.json 获取车端元数据
        self.vehicle_meta = load_vehicle_metadata()
        
        # 3. 构建有效样本列表
        self.samples = []
        for item in self.coop_data:
            v_frame_id = extract_frame_id(item['vehicle_image_path'])    # e.g., "015438"
            i_frame_id = extract_frame_id(item['infrastructure_image_path'])  # e.g., "000084"
            
            # 检查 GT 轨迹是否存在
            if exists(f"ground_truth_trajectories/{v_frame_id}.npy"):
                self.samples.append({
                    'vehicle_frame_id': v_frame_id,
                    'infra_frame_id': i_frame_id,
                    ...
                })
    
    def __getitem__(self, idx):
        sample = self.samples[idx]
        
        # 根据 frame_id 读取对应图像 (不同的ID!)
        v_image = load_image(f"vehicle-side-image/{sample['vehicle_frame_id']}.jpg")
        i_image = load_image(f"infra-side-image/{sample['infra_frame_id']}.jpg")
        
        # 拼接图像
        combined = concat_images(v_image, i_image)
        
        # 加载轨迹 (用 vehicle_frame_id)
        trajectory = np.load(f"ground_truth_trajectories/{sample['vehicle_frame_id']}.npy")
        
        return combined, trajectory
```

---

## 7. 总结：三个 ID 的关系

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        cooperative/data_info.json                           │
│                                                                             │
│   配对记录 i:                                                                │
│   ├── vehicle_frame_id: "015438"  ←──────────────────────────┐             │
│   │       │                                                   │             │
│   │       ▼                                                   │             │
│   │   ┌─────────────────────────────────────┐                 │             │
│   │   │ vehicle-side/data_info.json         │                 │             │
│   │   │ frame "015438":                     │                 │             │
│   │   │   batch_id: "34"                    │ ──→ 用于组织    │             │
│   │   │   timestamp: 1626247179676000       │     时间连续帧   │             │
│   │   │   novatel_to_world: 015438.json     │ ──→ 用于生成GT  │             │
│   │   └─────────────────────────────────────┘                 │             │
│   │                                                           │             │
│   └── infra_frame_id: "000084"  (独立ID，仅用于读取路端图像)   │             │
│                                                               │             │
│   GT轨迹: ground_truth_trajectories/015438.npy ←──────────────┘             │
│   (使用 vehicle_frame_id 命名，因为轨迹是自车的)                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 8. 常见问题

### Q: 为什么路端没有 batch_id 用于轨迹生成？

路端摄像头是固定的，不移动，所以：
- 路端图像用于**补充视角信息**，帮助理解场景
- 轨迹是**自车的运动**，只与车端数据相关
- 路端的 batch_id 表示的是该摄像头的录制场景，与车端 batch 不同

### Q: 为什么 cooperative 只有 6617 帧，而 vehicle-side 有 15285 帧？

- `cooperative/data_info.json` 只包含**车路配对成功**的帧
- 很多车端帧在录制时，对应的路侧摄像头没有覆盖或数据丢失
- 我们只使用配对成功的帧进行训练

### Q: GT轨迹用哪个 frame_id 命名？

用 **vehicle_frame_id**，因为：
- 轨迹是自车的未来位置
- 位姿数据来自车端的 `novatel_to_world`
- 命名一致便于数据加载
